
<!-- Claude Code -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Connected Circles Network</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            height: 100vh;
            overflow: hidden;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            font-family: Arial, sans-serif;
            position: relative;
        }

        .container {
            position: relative;
            width: 100%;
            height: 100vh;
        }

        .circle {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            animation: float 4s ease-in-out infinite;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .circle::before {
            content: '';
            position: absolute;
            top: 10px;
            left: 10px;
            width: 20px;
            height: 20px;
            background: rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            filter: blur(5px);
        }

        .circle:hover {
            transform: scale(1.3);
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.5);
        }

        .circle:nth-child(2n) {
            background: linear-gradient(45deg, #a8edea, #fed6e3);
            animation-delay: -1s;
        }

        .circle:nth-child(3n) {
            background: linear-gradient(45deg, #ffecd2, #fcb69f);
            animation-delay: -2s;
        }

        .circle:nth-child(4n) {
            background: linear-gradient(45deg, #667eea, #764ba2);
            animation-delay: -3s;
        }

        .circle:nth-child(5n) {
            background: linear-gradient(45deg, #f093fb, #f5576c);
            animation-delay: -0.5s;
        }

        @keyframes float {
            0%, 100% {
                transform: translateY(0px);
            }
            25% {
                transform: translateY(-10px);
            }
            50% {
                transform: translateY(-5px);
            }
            75% {
                transform: translateY(-15px);
            }
        }

        .line {
            position: absolute;
            height: 2px;
            background: linear-gradient(90deg, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.1));
            transform-origin: left center;
            animation: pulse-line 3s ease-in-out infinite;
            z-index: -1;
        }

        @keyframes pulse-line {
            0%, 100% {
                opacity: 0.3;
                filter: blur(0px);
            }
            50% {
                opacity: 0.8;
                filter: blur(1px);
            }
        }

        .title {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 100;
            text-align: center;
        }

        .description {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.8);
            font-size: 16px;
            text-align: center;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="title">Connected Network</h1>
        <p class="description">Interactive circles with dynamic connections</p>
    </div>

    <script>
        const container = document.querySelector('.container');
        const circles = [];
        const lines = [];
        const numCircles = 12;

        // Create circles in a centered area
        for (let i = 0; i < numCircles; i++) {
            const circle = document.createElement('div');
            circle.className = 'circle';
            
            // Define centered area (70% of screen, centered)
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            const areaWidth = window.innerWidth * 0.7;
            const areaHeight = window.innerHeight * 0.7;
            
            const x = centerX - areaWidth/2 + Math.random() * areaWidth;
            const y = centerY - areaHeight/2 + Math.random() * areaHeight;
            
            circle.style.left = x + 'px';
            circle.style.top = y + 'px';
            
            container.appendChild(circle);
            circles.push({
                element: circle,
                x: x + 30, // Center of circle
                y: y + 30
            });
        }

        // Function to calculate distance between two points
        function distance(p1, p2) {
            return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
        }

        // Function to create a line between two circles
        function createLine(circle1, circle2) {
            const line = document.createElement('div');
            line.className = 'line';
            
            const dx = circle2.x - circle1.x;
            const dy = circle2.y - circle1.y;
            const length = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;
            
            line.style.width = length + 'px';
            line.style.left = circle1.x + 'px';
            line.style.top = circle1.y + 'px';
            line.style.transform = `rotate(${angle}deg)`;
            
            container.appendChild(line);
            return line;
        }

        // Connect circles that are close to each other
        const maxDistance = 300;
        for (let i = 0; i < circles.length; i++) {
            for (let j = i + 1; j < circles.length; j++) {
                const dist = distance(circles[i], circles[j]);
                if (dist < maxDistance) {
                    const line = createLine(circles[i], circles[j]);
                    lines.push(line);
                }
            }
        }

        // Mouse interaction variables
        let mouseX = 0;
        let mouseY = 0;
        const pushForce = 80; // Distance at which mouse affects circles
        const pushStrength = 0.3; // How strongly circles are pushed

        // Track mouse position
        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        // Add interactive hover effects
        circles.forEach((circle, index) => {
            circle.element.addEventListener('mouseenter', () => {
                // Highlight connected lines
                lines.forEach(line => {
                    line.style.background = 'linear-gradient(90deg, rgba(255, 107, 107, 0.8), rgba(78, 205, 196, 0.8))';
                    line.style.height = '3px';
                });
            });
            
            circle.element.addEventListener('mouseleave', () => {
                // Reset lines
                lines.forEach(line => {
                    line.style.background = 'linear-gradient(90deg, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.1))';
                    line.style.height = '2px';
                });
            });

            // Store original and current positions
            circle.originalX = parseFloat(circle.element.style.left);
            circle.originalY = parseFloat(circle.element.style.top);
            circle.currentX = circle.originalX;
            circle.currentY = circle.originalY;
            circle.velocityX = 0;
            circle.velocityY = 0;
        });

        // Animate circles with mouse interaction
        function animateCircles() {
            circles.forEach((circle, index) => {
                // Calculate distance from mouse to circle center
                const circleCenterX = circle.currentX + 30;
                const circleCenterY = circle.currentY + 30;
                const distanceToMouse = Math.sqrt(
                    Math.pow(mouseX - circleCenterX, 2) + 
                    Math.pow(mouseY - circleCenterY, 2)
                );

                // If mouse is close enough, push the circle away
                if (distanceToMouse < pushForce && distanceToMouse > 0) {
                    const angle = Math.atan2(circleCenterY - mouseY, circleCenterX - mouseX);
                    const force = (pushForce - distanceToMouse) / pushForce;
                    
                    circle.velocityX += Math.cos(angle) * force * pushStrength;
                    circle.velocityY += Math.sin(angle) * force * pushStrength;
                }

                // Apply velocity with damping
                circle.currentX += circle.velocityX;
                circle.currentY += circle.velocityY;
                circle.velocityX *= 0.95; // Damping
                circle.velocityY *= 0.95;

                // Keep circles within bounds
                const margin = 50;
                if (circle.currentX < margin) {
                    circle.currentX = margin;
                    circle.velocityX = Math.abs(circle.velocityX) * 0.5;
                }
                if (circle.currentX > window.innerWidth - 60 - margin) {
                    circle.currentX = window.innerWidth - 60 - margin;
                    circle.velocityX = -Math.abs(circle.velocityX) * 0.5;
                }
                if (circle.currentY < margin) {
                    circle.currentY = margin;
                    circle.velocityY = Math.abs(circle.velocityY) * 0.5;
                }
                if (circle.currentY > window.innerHeight - 60 - margin) {
                    circle.currentY = window.innerHeight - 60 - margin;
                    circle.velocityY = -Math.abs(circle.velocityY) * 0.5;
                }

                // Gentle pull back towards original position
                const returnForce = 0.02;
                const deltaX = circle.originalX - circle.currentX;
                const deltaY = circle.originalY - circle.currentY;
                circle.velocityX += deltaX * returnForce;
                circle.velocityY += deltaY * returnForce;

                // Update circle position
                circle.element.style.left = circle.currentX + 'px';
                circle.element.style.top = circle.currentY + 'px';

                // Update position for line calculations
                circle.x = circle.currentX + 30;
                circle.y = circle.currentY + 30;
            });

            // Update connection lines
            updateLines();
            
            requestAnimationFrame(animateCircles);
        }

        // Function to update connection lines
        function updateLines() {
            lines.forEach(line => line.remove());
            lines.length = 0;
            
            for (let i = 0; i < circles.length; i++) {
                for (let j = i + 1; j < circles.length; j++) {
                    const dist = distance(circles[i], circles[j]);
                    if (dist < maxDistance) {
                        const line = createLine(circles[i], circles[j]);
                        lines.push(line);
                    }
                }
            }
        }

        animateCircles();

        // Handle window resize
        window.addEventListener('resize', () => {
            // Remove existing lines
            lines.forEach(line => line.remove());
            lines.length = 0;
            
            // Recreate connections
            for (let i = 0; i < circles.length; i++) {
                for (let j = i + 1; j < circles.length; j++) {
                    const dist = distance(circles[i], circles[j]);
                    if (dist < maxDistance) {
                        const line = createLine(circles[i], circles[j]);
                        lines.push(line);
                    }
                }
            }
        });
    </script>
</body>
</html>